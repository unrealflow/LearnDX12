# LearnDX12

## 初始化流程

1. 初始化窗口
2. 初始化设备，创建指令队列及交换链
3. 创建描述符堆，创建基本的渲染目标及深度缓冲
4. 创建指令池
5. 创建摄像机
6. 导入模型，创建顶点、索引缓冲
7. 将相机矩阵及其他信息写入缓冲
8. 加载纹理贴图

## GBuffer Pass
* Cpp：
    1. 创建GBuffer缓冲
    2. 为GBuffer创建RTV、SRV
    3. 创建pipeline
    4. 记录指令

* Vertex Shader：
    1. 输入：
        * 顶点位置
        * 顶点法线
        * 顶点纹理坐标
    2. 对顶点进行投影变换
    3. 将深度写入到位置信息的w分量
    4. 输出：
        * 屏幕坐标位置
        * 法线
        * 纹理坐标
        * 世界坐标位置

* Pixel Shader：
    1. 输入：
        * 世界坐标位置
        * 法线
        * 纹理坐标
    2. 通过纹理坐标读取贴图颜色
    3. 输出：
        * 世界坐标位置
        * 法线
        * 颜色
        
## SSAO Pass
* Cpp：
    1. 创建AO缓冲
    2. 为AO缓冲创建RTV、SRV
    3. 创建pipeline
    4. 记录指令
* Vertex Shader：
    1. 输入：
        * 顶点索引
    2. 根据索引生成顶点位置及UV，三顶点构成一个覆盖整个屏幕的三角型
    3. 输出：
        * 屏幕坐标位置
        * 纹理坐标
* Pixel Shader：
    1. 输入：
        * 纹理坐标
    2. 根据uv读取GBuffer数据，跳过空像素
    3. 声明浮点数weight，初始值为0，记录遮蔽程度 
    4. For循环，次数count：
        1. 根据法线方向，生成一个分布在法线半球区域内的随机值，半球半径为r
        2. 用当前像素位置加上该随机值，得到位置P
        3. 将P变换至屏幕空间，得到对应的纹理坐标p_uv
        4. 从GBuffer中读取p_uv对应的深度g_z，与位置P的深度p_z做比较
        5. 如果g_z的深度小于p_z，且深度差小于r，表明位置P被其附近物体遮挡，weight+=1.0
    5. (1.0-weight/count)即为当前像素的光遮蔽因子，1.0表示没有被遮蔽，0.0表示物体完全被遮蔽
    6. 输出：
        * 光遮蔽因子

* 球面均匀分布的随机值：
    1. 通过积分可知，相同高度差对应的球表面积相同
    2. 获取一个 `[0,1)` 的随机数 `f0` 
    3. 令 `r = sqrt(1.0 - f0*f0)`
    4. 获取一个 `[0,1)*2.0*PI` 的随机数 `f1` 
    5. 令 `v = (r*cos(f1), r*sin(f1),f0)`
    6. 则 `v` 即为所求

## Blur Pass

* cpp：
    1. 创建计算管线
    2. 为输入图像创建SRV
    3. 为输出图像创建UAV
    4. 记录指令
   
* Computer Shader：
    1. 输入：
        * GroupID
        * 输入图像

    2. 高斯模糊
    3. 输出：
       * 将结果写入输出图像
    
