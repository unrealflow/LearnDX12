# LearnDX12

## 初始化流程

1. 初始化窗口
2. 初始化设备，创建指令队列及交换链
3. 创建描述符堆，创建基本的渲染目标及深度缓冲
4. 创建指令池
5. 创建摄像机
6. 导入模型，创建顶点、索引缓冲
7. 将相机矩阵及其他信息写入缓冲
8. 加载纹理贴图

## GBuffer Pass
* Cpp：
    1. 创建GBuffer缓冲
    2. 为GBuffer创建RTV、SRV
    3. 创建描述符根签名
    4. 创建pipeline
    5. 记录指令

* Vertex Shader：
    1. 输入：
        * 顶点位置
        * 顶点法线
        * 顶点纹理坐标
        * VP矩阵
    2. 对顶点进行投影变换
    3. 将深度写入到位置信息的w分量
    4. 输出：
        * 屏幕坐标位置
        * 法线
        * 纹理坐标
        * 世界坐标位置

* Pixel Shader：
    1. 输入：
        * 世界坐标位置
        * 法线
        * 纹理坐标
        * 贴图
    2. 通过纹理坐标读取贴图颜色
    3. 输出：
        * 世界坐标位置
        * 法线
        * 颜色
        
## SSAO Pass
* Cpp：
    1. 创建AO缓冲
    2. 为AO缓冲创建RTV、SRV
    3. 创建描述符根签名
    4. 创建pipeline
    5. 记录指令
* Vertex Shader：
    1. 输入：
        * 顶点索引
    2. 根据索引生成顶点位置及UV，三顶点构成一个覆盖整个屏幕的三角型
    3. 输出：
        * 屏幕坐标位置
        * 纹理坐标
* Pixel Shader：
    1. 输入：
        * 纹理坐标
        * GBuffer
        * VP矩阵
    2. 根据uv读取GBuffer数据，跳过空像素
    3. 声明浮点数weight，初始值为0，记录遮蔽程度 
    4. For循环，次数count：
        1. 根据法线方向，生成一个分布在法线半球区域内的随机值，半球半径为r
        2. 用当前像素位置加上该随机值，得到位置P
        3. 将P变换至屏幕空间，得到对应的纹理坐标p_uv
        4. 从GBuffer中读取p_uv对应的深度g_z，与位置P的深度p_z做比较
        5. 如果g_z的深度小于p_z，且深度差小于r，表明位置P被其附近物体遮挡，weight+=1.0
    5. (1.0-weight/count)即为当前像素的光遮蔽因子，1.0表示没有被遮蔽，0.0表示物体完全被遮蔽
    6. 输出：
        * 光遮蔽因子

* 球面均匀分布的随机值：
    1. 通过积分可知，相同高度差对应的球表面积相同
    2. 获取一个 `[0,1)` 的随机数 `f0` 
    3. 令 `r = sqrt(1.0 - f0*f0)`
    4. 获取一个 `[0,1)*2.0*PI` 的随机数 `f1` 
    5. 令 `v = (r*cos(f1), r*sin(f1),f0)`
    6. 则 `v` 即为所求

## Blur Pass

* Cpp：
    1. 创建描述符根签名
    2. 创建计算管线
    3. 为输入图像创建SRV
    4. 为输出图像创建UAV
    5. 记录指令（用模糊后的图像覆盖输入图像）
   
* Computer Shader：
    1. 输入：
        * GroupID
        * 输入图像

    2. 高斯模糊
    3. 输出：
       * 模糊后的图像
    
## Deferred Pass
* Cpp：
    1. 创建图像，作为渲染目标
    2. 为图像创建RTV、SRV
    3. 创建描述符根签名
    4. 创建pipeline
    5. 记录指令

* Vertex Shader：
    1. 输入：
        * 顶点索引
    2. 根据索引生成顶点位置及UV，三顶点构成一个覆盖整个屏幕的三角型
    3. 输出：
        * 屏幕坐标位置
        * 纹理坐标

* Pixel Shader：
    1. 输入：
        * GBuffer
        * 纹理坐标
        * AO缓冲
        * 背景贴图
        * 相机位置
        * 光源位置
    2. 根据uv从GBuffer中读取位置信息
    3. 判断，若当前像素为空像素，则从背景贴图中获取背景颜色，输出
    4. 从GBuffer读取法线和基础颜色
    5. 从AO缓冲中读取ao系数，并乘上基础颜色作为新的基础颜色
    6. 计算视线方向和光源方向
    7. 计算距离衰减系数
    8. BRDF计算
    9. 计算反射效果颜色
    10. 根据粗糙度进行颜色混合
    11. 伽马矫正
    12. 输出：
        * 最终颜色
  
## 渲染循环
    1. 更新VP矩阵及其他常量信息
    2. 等待，提交指令
    3. 图像呈现，发出等待信号，开始下一帧
